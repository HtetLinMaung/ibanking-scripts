import axios, { AxiosRequestConfig, AxiosResponse } from "axios";

const timeout = (ms: number) =>
  new Promise((resolve) => setTimeout(resolve, ms));

const get = async (url: string, config?: AxiosRequestConfig<any>) => {
  try {
    const response = await axios.get(url, config);
    return [response, null];
  } catch (err) {
    if ("response" in err) {
      return [err.response, null];
    }
    return [null, err];
  }
};

const post = async (
  url: string,
  data?: any,
  config?: AxiosRequestConfig<any>
) => {
  try {
    const response = await axios.post(url, data, config);
    return [response, null];
  } catch (err) {
    if ("response" in err) {
      return [err.response, null];
    }
    return [null, err];
  }
};

const put = async (
  url: string,
  data?: any,
  config?: AxiosRequestConfig<any>
) => {
  try {
    const response = await axios.put(url, data, config);
    return [response, null];
  } catch (err) {
    if ("response" in err) {
      return [err.response, null];
    }
    return [null, err];
  }
};

const destroy = async (url: string, config?: AxiosRequestConfig<any>) => {
  try {
    const response = await axios.delete(url, config);
    return [response, null];
  } catch (err) {
    if ("response" in err) {
      return [err.response, null];
    }
    return [null, err];
  }
};

const patch = async (
  url: string,
  data?: any,
  config?: AxiosRequestConfig<any>
) => {
  try {
    const response = await axios.patch(url, data, config);
    return [response, null];
  } catch (err) {
    if ("response" in err) {
      return [err.response, null];
    }
    return [null, err];
  }
};

export interface ClientOptions {
  retry?: number;
  retryDelay?: number;
  retryWhen?: (response: AxiosResponse<any, any>, error: any) => boolean;
  interval?: number;
  requestUntil?: (response: AxiosResponse<any, any>, error: any) => boolean;
}

export default {
  get: async (
    url: string,
    config?: AxiosRequestConfig<any>,
    options: ClientOptions = {}
  ) => {
    const defaultOptions: ClientOptions = {
      retry: 0,
      retryDelay: 0,
      interval: 0,
      requestUntil: (res, err) => true,
      retryWhen: (res, err) => !res || res.status >= 400,
      ...options,
    };
    let response = null;
    let err = null;

    if (defaultOptions.interval > 0) {
      [response, err] = await (() =>
        new Promise((resolve, reject) => {
          const intervalId = setInterval(() => {
            get(url, config)
              .then(([res, err]) => {
                if (defaultOptions.requestUntil(res, err)) {
                  resolve([res, err]);
                  clearInterval(intervalId);
                }
              })
              .catch(reject);
          }, defaultOptions.interval);
        }))();
    } else {
      [response, err] = await get(url, config);
    }

    let i = 0;
    while (
      defaultOptions.retryWhen(response, err) &&
      i < defaultOptions.retry
    ) {
      if (defaultOptions.retryDelay > 0) {
        await timeout(defaultOptions.retryDelay);
      }
      [response, err] = await get(url, config);
      i++;
    }
    return [response, err];
  },
  post: async (
    url: string,
    data?: any,
    config?: AxiosRequestConfig<any>,
    options: ClientOptions = {}
  ) => {
    const defaultOptions: ClientOptions = {
      retry: 0,
      retryDelay: 0,
      interval: 0,
      requestUntil: (res, err) => true,
      retryWhen: (res, err) => !res || res.status >= 400,
      ...options,
    };
    let response = null;
    let err = null;

    if (defaultOptions.interval > 0) {
      [response, err] = await (() =>
        new Promise((resolve, reject) => {
          const intervalId = setInterval(() => {
            post(url, data, config)
              .then(([res, err]) => {
                if (defaultOptions.requestUntil(res, err)) {
                  resolve([res, err]);
                  clearInterval(intervalId);
                }
              })
              .catch(reject);
          }, defaultOptions.interval);
        }))();
    } else {
      [response, err] = await post(url, data, config);
    }

    let i = 0;
    while (
      defaultOptions.retryWhen(response, err) &&
      i < defaultOptions.retry
    ) {
      if (defaultOptions.retryDelay > 0) {
        await timeout(defaultOptions.retryDelay);
      }
      [response, err] = await post(url, data, config);
      i++;
    }
    return [response, err];
  },
  put: async (
    url: string,
    data?: any,
    config?: AxiosRequestConfig<any>,
    options: ClientOptions = {}
  ) => {
    const defaultOptions: ClientOptions = {
      retry: 0,
      retryDelay: 0,
      interval: 0,
      requestUntil: (res, err) => true,
      retryWhen: (res, err) => !res || res.status >= 400,
      ...options,
    };
    let response = null;
    let err = null;

    if (defaultOptions.interval > 0) {
      [response, err] = await (() =>
        new Promise((resolve, reject) => {
          const intervalId = setInterval(() => {
            put(url, data, config)
              .then(([res, err]) => {
                if (defaultOptions.requestUntil(res, err)) {
                  resolve([res, err]);
                  clearInterval(intervalId);
                }
              })
              .catch(reject);
          }, defaultOptions.interval);
        }))();
    } else {
      [response, err] = await put(url, data, config);
    }

    let i = 0;
    while (
      defaultOptions.retryWhen(response, err) &&
      i < defaultOptions.retry
    ) {
      if (defaultOptions.retryDelay > 0) {
        await timeout(defaultOptions.retryDelay);
      }
      [response, err] = await put(url, data, config);
      i++;
    }
    return [response, err];
  },
  patch: async (
    url: string,
    data?: any,
    config?: AxiosRequestConfig<any>,
    options: ClientOptions = {}
  ) => {
    const defaultOptions: ClientOptions = {
      retry: 0,
      retryDelay: 0,
      interval: 0,
      requestUntil: (res, err) => true,
      retryWhen: (res, err) => !res || res.status >= 400,
      ...options,
    };
    let response = null;
    let err = null;

    if (defaultOptions.interval > 0) {
      [response, err] = await (() =>
        new Promise((resolve, reject) => {
          const intervalId = setInterval(() => {
            patch(url, data, config)
              .then(([res, err]) => {
                if (defaultOptions.requestUntil(res, err)) {
                  resolve([res, err]);
                  clearInterval(intervalId);
                }
              })
              .catch(reject);
          }, defaultOptions.interval);
        }))();
    } else {
      [response, err] = await patch(url, data, config);
    }

    let i = 0;
    while (
      defaultOptions.retryWhen(response, err) &&
      i < defaultOptions.retry
    ) {
      if (defaultOptions.retryDelay > 0) {
        await timeout(defaultOptions.retryDelay);
      }
      [response, err] = await patch(url, data, config);
      i++;
    }
    return [response, err];
  },
  delete: async (
    url: string,
    config?: AxiosRequestConfig<any>,
    options: ClientOptions = {}
  ) => {
    const defaultOptions: ClientOptions = {
      retry: 0,
      retryDelay: 0,
      interval: 0,
      requestUntil: (res, err) => true,
      retryWhen: (res, err) => !res || res.status >= 400,
      ...options,
    };
    let response = null;
    let err = null;

    if (defaultOptions.interval > 0) {
      [response, err] = await (() =>
        new Promise((resolve, reject) => {
          const intervalId = setInterval(() => {
            destroy(url, config)
              .then(([res, err]) => {
                if (defaultOptions.requestUntil(res, err)) {
                  resolve([res, err]);
                  clearInterval(intervalId);
                }
              })
              .catch(reject);
          }, defaultOptions.interval);
        }))();
    } else {
      [response, err] = await destroy(url, config);
    }

    let i = 0;
    while (
      defaultOptions.retryWhen(response, err) &&
      i < defaultOptions.retry
    ) {
      if (defaultOptions.retryDelay > 0) {
        await timeout(defaultOptions.retryDelay);
      }
      [response, err] = await destroy(url, config);
      i++;
    }
    return [response, err];
  },
};
